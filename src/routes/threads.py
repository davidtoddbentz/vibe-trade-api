"""Thread management endpoints."""

from typing import Annotated

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field

from src.auth import get_user_id
from src.models.thread import Thread
from src.repositories import firestore_client

router = APIRouter(prefix="/api/threads", tags=["threads"])

# Thread repository (will be moved to repositories.py when implemented)
_thread_collection = "threads"


class CreateThreadRequest(BaseModel):
    """Request model for creating a thread."""

    strategy_id: str | None = Field(None, description="Optional strategy to link to thread")
    metadata: dict = Field(default_factory=dict, description="Optional thread metadata")


class ThreadResponse(BaseModel):
    """Response model for thread data."""

    id: str
    user_id: str
    strategy_id: str | None
    created_at: str
    updated_at: str
    metadata: dict


@router.post("", response_model=ThreadResponse, status_code=status.HTTP_201_CREATED)
async def create_thread(
    request: CreateThreadRequest,
    user_id: Annotated[str, Depends(get_user_id)],
) -> ThreadResponse:
    """Create a new thread for the authenticated user.

    Args:
        request: Thread creation request
        user_id: User ID from JWT (verified, not from user input)

    Returns:
        Created thread data
    """
    # Create thread
    now = Thread.now_iso()
    thread = Thread(
        id="",  # Will be generated by Firestore
        user_id=user_id,
        strategy_id=request.strategy_id,
        created_at=now,
        updated_at=now,
        metadata=request.metadata,
    )

    # Add to Firestore (auto-generates document ID)
    thread_dict = thread.to_dict()
    doc_ref = firestore_client.collection(_thread_collection).add(thread_dict)[1]

    # Return thread with generated ID
    created_thread = Thread.from_dict(thread_dict, thread_id=doc_ref.id)

    return ThreadResponse(
        id=created_thread.id,
        user_id=created_thread.user_id,
        strategy_id=created_thread.strategy_id,
        created_at=created_thread.created_at,
        updated_at=created_thread.updated_at,
        metadata=created_thread.metadata,
    )


@router.get("", response_model=list[ThreadResponse])
async def list_threads(
    user_id: Annotated[str, Depends(get_user_id)],
) -> list[ThreadResponse]:
    """List all threads for the authenticated user.

    Args:
        user_id: User ID from JWT (verified, not from user input)

    Returns:
        List of user's threads
    """
    # Query threads where user_id matches
    query = firestore_client.collection(_thread_collection).where("user_id", "==", user_id)
    docs = query.stream()

    threads = []
    for doc in docs:
        data = doc.to_dict()
        if data:
            thread = Thread.from_dict(data, thread_id=doc.id)
            threads.append(
                ThreadResponse(
                    id=thread.id,
                    user_id=thread.user_id,
                    strategy_id=thread.strategy_id,
                    created_at=thread.created_at,
                    updated_at=thread.updated_at,
                    metadata=thread.metadata,
                )
            )

    return threads


@router.get("/{thread_id}", response_model=ThreadResponse)
async def get_thread(
    thread_id: str,
    user_id: Annotated[str, Depends(get_user_id)],
) -> ThreadResponse:
    """Get a thread by ID (ensures user owns it).

    Args:
        thread_id: Thread identifier
        user_id: User ID from JWT (verified, not from user input)

    Returns:
        Thread data

    Raises:
        HTTPException: If thread not found or user doesn't own it
    """
    doc_ref = firestore_client.collection(_thread_collection).document(thread_id)
    doc = doc_ref.get()

    if not doc.exists:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Thread not found: {thread_id}",
        )

    data = doc.to_dict()
    if data is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Thread not found: {thread_id}",
        )

    thread = Thread.from_dict(data, thread_id=doc.id)

    # Verify user owns this thread
    if thread.user_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied: thread belongs to another user",
        )

    return ThreadResponse(
        id=thread.id,
        user_id=thread.user_id,
        strategy_id=thread.strategy_id,
        created_at=thread.created_at,
        updated_at=thread.updated_at,
        metadata=thread.metadata,
    )

